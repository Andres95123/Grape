package com.grape.cup;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

import java_cup.runtime.*;

import java.io.*;

import com.grape.utils.*;

//Librerias
import java.util.Stack;

class Parser;

parser code {:

/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
  
  // Estructuras de datos para almacenar los errores

  Stack<Bloque> pilaBloques = new Stack<>();



  /**********************************************************************
   * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
   **********************************************************************/

  @Override
  public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
    report_error("Error de sintaxis catastrofico", cur_token);
    done_parsing();    
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    report_error("de sintaxis", cur_token);
  }

  @Override
  public void report_error(String message, Object info) {
    StringBuilder msg = new StringBuilder("ERROR");
    if (info instanceof Symbol) {
      ComplexSymbol token = (ComplexSymbol)info;
      Location l = token.getLeft();
      
      if (l != null) {
        msg.append(" (fila: ")
          .append(l.getLine())
          .append(", columna: ")
          .append(l.getColumn())
          .append(")");
      }
    }
    msg.append(": ").append(message);
    
    System.err.println(msg);
  }

  @Override
  public void report_fatal_error(String message, Object info) throws Exception {
    report_error("Error catastrofico irrecuperable ("+message+")", info);
    done_parsing();
  }


:}


/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:   next_token(); :}
**/

/*Declaraciones Valores*/
terminal ValueContainer VALUE;
terminal String ID;

/*Declaracion Tipos*/
terminal Tipo VAR_TYPE;
terminal DETERMINE,VAR_INVOKER, INFER_INVOKER, FIX_INVOKER;

/*Declaraciones Operaciones*/
terminal PLUS,MINUS,MULT,DIV,MOD,ASSIGN;

/*Declaraciones Especiales*/
terminal Endline;

non terminal CODESTART, START_ACTIONS, COMANDOS, VARIABLE_DEFINITION, VAR_DEFINITION, INFER_DEFINITION, TYPE_SELECTOR;
non terminal Var EXPRESION;

//Precedencias Estandar
precedence right ASSIGN ;
// precedence left AND, XOR, OR, NOT;
precedence left PLUS,MINUS ;
precedence left MULT, DIV, MOD ;

start with CODESTART;

// Inicio de la gramatica

CODESTART ::= {: pilaBloques.push(new Bloque()); :} COMANDOS 
{: 
for(Bloque bloque : pilaBloques){
  System.out.println(bloque.toString());
} 

for(IR ir : IR.irDeque){
  System.out.println(ir.toString());
}


:} ;

COMANDOS ::= VARIABLE_DEFINITION COMANDOS |   ;

VARIABLE_DEFINITION ::= VAR_DEFINITION | INFER_DEFINITION ;

// Definicion de variables

VAR_DEFINITION ::= VAR_INVOKER ID:name DETERMINE VAR_TYPE:tipe ASSIGN EXPRESION:val Endline {:

  if (!val.isType(tipe)){
    report_fatal_error (name + " no es de tipo " + val.getType(), val);
  }

 pilaBloques.peek().addVar(name,val); 

:} ;

INFER_DEFINITION ::= INFER_INVOKER ID:name ASSIGN EXPRESION:val Endline {:

  pilaBloques.peek().addVar(name,val);

:};


EXPRESION ::= VALUE:val {: RESULT = new Var(val.getType(),val.getValue(),true); :} | ID:val {: RESULT = pilaBloques.peek().getVar(val); :}
| EXPRESION:e1 PLUS EXPRESION:e2 {: Var tmp = e1.sumar(e2); pilaBloques.peek().addVar(tmp.getNombre(),tmp); RESULT = tmp; :}
| EXPRESION:e1 MINUS EXPRESION:e2 {: Var tmp = e1.restar(e2); pilaBloques.peek().addVar(tmp.getNombre(),tmp); RESULT = tmp; :}
| EXPRESION:e1 MULT EXPRESION:e2 {: Var tmp = e1.multiplicar(e2); pilaBloques.peek().addVar(tmp.getNombre(),tmp); RESULT = tmp; :}
| EXPRESION:e1 DIV EXPRESION:e2 {: Var tmp = e1.dividir(e2); pilaBloques.peek().addVar(tmp.getNombre(),tmp); RESULT = tmp; :}
| EXPRESION:e1 MOD EXPRESION:e2 {: Var tmp = e1.modulo(e2); pilaBloques.peek().addVar(tmp.getNombre(),tmp); RESULT = tmp; :};

